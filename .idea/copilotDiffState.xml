<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/fr/eseo/b3/agtr/narvalo/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/fr/eseo/b3/agtr/narvalo/MainActivity.kt" />
              <option name="originalContent" value="package fr.eseo.b3.agtr.narvalo&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import fr.eseo.b3.agtr.narvalo.ui.theme.NarvaloTheme&#10;import fr.eseo.b3.agtr.narvalo.ui.screens.QuizScreen&#10;import fr.eseo.b3.agtr.narvalo.ui.screens.HomeScreen&#10;import fr.eseo.b3.agtr.narvalo.MusicPlayer.MusicPlayerManager&#10;&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContent {&#10;            val context = LocalContext.current&#10;            val musicPlayerManager = remember { MusicPlayerManager(context) }&#10;&#10;            // État pour la navigation&#10;            var currentScreen by remember { mutableStateOf(&quot;home&quot;) }&#10;            var highScore by remember { mutableStateOf(0) }&#10;            var lastScore by remember { mutableStateOf(0) }&#10;&#10;            DisposableEffect(Unit) {&#10;                onDispose {&#10;                    musicPlayerManager.release()&#10;                }&#10;            }&#10;&#10;            NarvaloTheme {&#10;                Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                    when (currentScreen) {&#10;                        &quot;home&quot; -&gt; HomeScreen(&#10;                            onPlayClick = { currentScreen = &quot;quiz&quot; },&#10;                            modifier = Modifier.padding(innerPadding),&#10;                            highScore = highScore,&#10;                            lastScore = lastScore&#10;                        )&#10;                        &quot;quiz&quot; -&gt; QuizScreen(&#10;                            modifier = Modifier.padding(innerPadding),&#10;                            musicPlayerManager = musicPlayerManager,&#10;                            onQuizComplete = { score -&gt;&#10;                                lastScore = score&#10;                                if (score &gt; highScore) {&#10;                                    highScore = score&#10;                                }&#10;                                currentScreen = &quot;home&quot;&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package fr.eseo.b3.agtr.narvalo&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import fr.eseo.b3.agtr.narvalo.ui.theme.NarvaloTheme&#10;import fr.eseo.b3.agtr.narvalo.ui.screens.QuizScreen&#10;import fr.eseo.b3.agtr.narvalo.ui.screens.HomeScreen&#10;import fr.eseo.b3.agtr.narvalo.MusicPlayer.MusicPlayerManager&#10;import fr.eseo.b3.agtr.narvalo.data.ScoreManager&#10;&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContent {&#10;            val context = LocalContext.current&#10;            val musicPlayerManager = remember { MusicPlayerManager(context) }&#10;            val scoreManager = remember { ScoreManager(context) }&#10;            &#10;            // Charger les scores sauvegardés au démarrage&#10;            val savedScores = remember { scoreManager.loadScores() }&#10;            &#10;            // État pour la navigation&#10;            var currentScreen by remember { mutableStateOf(&quot;home&quot;) }&#10;            var highScore by remember { mutableStateOf(savedScores.highScore) }&#10;            var lastScore by remember { mutableStateOf(savedScores.lastScore) }&#10;&#10;            DisposableEffect(Unit) {&#10;                onDispose {&#10;                    musicPlayerManager.release()&#10;                }&#10;            }&#10;&#10;            NarvaloTheme {&#10;                Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                    when (currentScreen) {&#10;                        &quot;home&quot; -&gt; HomeScreen(&#10;                            onPlayClick = { currentScreen = &quot;quiz&quot; },&#10;                            modifier = Modifier.padding(innerPadding),&#10;                            highScore = highScore,&#10;                            lastScore = lastScore&#10;                        )&#10;                        &quot;quiz&quot; -&gt; QuizScreen(&#10;                            modifier = Modifier.padding(innerPadding),&#10;                            musicPlayerManager = musicPlayerManager,&#10;                            onQuizComplete = { score -&gt;&#10;                                lastScore = score&#10;                                if (score &gt; highScore) {&#10;                                    highScore = score&#10;                                }&#10;                                // Sauvegarder les scores dans le JSON&#10;                                scoreManager.saveScores(highScore, lastScore)&#10;                                currentScreen = &quot;home&quot;&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/fr/eseo/b3/agtr/narvalo/data/ScoreManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/fr/eseo/b3/agtr/narvalo/data/ScoreManager.kt" />
              <option name="updatedContent" value="package fr.eseo.b3.agtr.narvalo.data&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import com.google.gson.Gson&#10;import com.google.gson.annotations.SerializedName&#10;&#10;data class ScoreData(&#10;    @SerializedName(&quot;high_score&quot;)&#10;    val highScore: Int = 0,&#10;    @SerializedName(&quot;last_score&quot;)&#10;    val lastScore: Int = 0&#10;)&#10;&#10;class ScoreManager(context: Context) {&#10;    private val prefs: SharedPreferences = &#10;        context.getSharedPreferences(&quot;narvalo_scores&quot;, Context.MODE_PRIVATE)&#10;    private val gson = Gson()&#10;    &#10;    companion object {&#10;        private const val KEY_SCORES = &quot;scores_data&quot;&#10;    }&#10;    &#10;    /**&#10;     * Sauvegarde les scores dans un fichier JSON&#10;     */&#10;    fun saveScores(highScore: Int, lastScore: Int) {&#10;        val scoreData = ScoreData(highScore, lastScore)&#10;        val json = gson.toJson(scoreData)&#10;        prefs.edit().putString(KEY_SCORES, json).apply()&#10;    }&#10;    &#10;    /**&#10;     * Récupère les scores depuis le fichier JSON&#10;     */&#10;    fun loadScores(): ScoreData {&#10;        val json = prefs.getString(KEY_SCORES, null)&#10;        return if (json != null) {&#10;            try {&#10;                gson.fromJson(json, ScoreData::class.java)&#10;            } catch (e: Exception) {&#10;                ScoreData() // Retourne des scores par défaut en cas d'erreur&#10;            }&#10;        } else {&#10;            ScoreData() // Première utilisation&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Met à jour uniquement le dernier score&#10;     */&#10;    fun updateLastScore(score: Int) {&#10;        val currentScores = loadScores()&#10;        val newHighScore = maxOf(currentScores.highScore, score)&#10;        saveScores(newHighScore, score)&#10;    }&#10;    &#10;    /**&#10;     * Récupère uniquement le high score&#10;     */&#10;    fun getHighScore(): Int {&#10;        return loadScores().highScore&#10;    }&#10;    &#10;    /**&#10;     * Récupère uniquement le last score&#10;     */&#10;    fun getLastScore(): Int {&#10;        return loadScores().lastScore&#10;    }&#10;    &#10;    /**&#10;     * Réinitialise tous les scores&#10;     */&#10;    fun resetScores() {&#10;        saveScores(0, 0)&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/fr/eseo/b3/agtr/narvalo/ui/Quiz.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/fr/eseo/b3/agtr/narvalo/ui/Quiz.kt" />
              <option name="originalContent" value="package fr.eseo.b3.agtr.narvalo.ui&#10;&#10;import androidx.compose.foundation.BorderStroke&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.ui.draw.alpha&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.RectangleShape&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import fr.eseo.b3.agtr.narvalo.Question.QuizState&#10;import fr.eseo.b3.agtr.narvalo.Question.QuizViewModel&#10;import fr.eseo.b3.agtr.narvalo.R&#10;&#10;enum class Difficulty {&#10;    FACILE, MOYEN, DIFFICILE&#10;}&#10;&#10;@Composable&#10;fun QuizScreen(&#10;    modifier: Modifier = Modifier,&#10;    viewModel: QuizViewModel = viewModel()&#10;) {&#10;    var selectedDifficulty by remember { mutableStateOf(Difficulty.MOYEN) }&#10;    var isMusicEnabled by remember { mutableStateOf(true) }&#10;&#10;    val quizState by viewModel.quizState.collectAsState()&#10;    val currentQuestionIndex by viewModel.currentQuestionIndex.collectAsState()&#10;    val score by viewModel.score.collectAsState()&#10;    val correctAnswersCount by viewModel.correctAnswersCount.collectAsState()&#10;    &#10;    // Calculer le multiplicateur de difficulté&#10;    val difficultyMultiplier = when (selectedDifficulty) {&#10;        Difficulty.FACILE -&gt; 1&#10;        Difficulty.MOYEN -&gt; 3&#10;        Difficulty.DIFFICILE -&gt; 5&#10;    }&#10;&#10;    // Charger les questions au démarrage&#10;    LaunchedEffect(selectedDifficulty) {&#10;        val difficulty = when (selectedDifficulty) {&#10;            Difficulty.FACILE -&gt; &quot;easy&quot;&#10;            Difficulty.MOYEN -&gt; &quot;medium&quot;&#10;            Difficulty.DIFFICILE -&gt; &quot;hard&quot;&#10;        }&#10;        viewModel.loadQuestions(difficulty)&#10;    }&#10;&#10;    Box(&#10;        modifier = modifier.fillMaxSize()&#10;    ) {&#10;        // Image de fond&#10;        Image(&#10;            painter = painterResource(id = R.drawable.background_quiz),&#10;            contentDescription = &quot;Background&quot;,&#10;            modifier = Modifier.fillMaxSize(),&#10;            contentScale = ContentScale.Crop&#10;        )&#10;&#10;        when (val state = quizState) {&#10;            is QuizState.Loading -&gt; {&#10;                CircularProgressIndicator(&#10;                    modifier = Modifier.align(Alignment.Center)&#10;                )&#10;            }&#10;            is QuizState.Error -&gt; {&#10;                Column(&#10;                    modifier = Modifier&#10;                        .align(Alignment.Center)&#10;                        .padding(16.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    Text(&#10;                        text = state.message,&#10;                        color = Color.Red,&#10;                        textAlign = TextAlign.Center&#10;                    )&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                    Button(onClick = { viewModel.loadQuestions() }) {&#10;                        Text(&quot;Réessayer&quot;)&#10;                    }&#10;                }&#10;            }&#10;            is QuizState.Success -&gt; {&#10;                val questions = state.questions&#10;&#10;                if (currentQuestionIndex &lt; questions.size) {&#10;                    val currentQuestion = questions[currentQuestionIndex]&#10;                    val answers = remember(currentQuestionIndex) {&#10;                        currentQuestion.getAllAnswers()&#10;                    }&#10;&#10;                    var selectedAnswer by remember(currentQuestionIndex) { mutableStateOf&lt;String?&gt;(null) }&#10;                    var hasAnswered by remember(currentQuestionIndex) { mutableStateOf(false) }&#10;&#10;                    // Passer automatiquement à la question suivante après un délai&#10;                    LaunchedEffect(hasAnswered) {&#10;                        if (hasAnswered) {&#10;                            kotlinx.coroutines.delay(1000)&#10;                            viewModel.nextQuestion()&#10;                        }&#10;                    }&#10;&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .fillMaxSize()&#10;                            .padding(start = 16.dp, end = 16.dp, top = 16.dp, bottom = 80.dp),&#10;                        verticalArrangement = Arrangement.SpaceBetween&#10;                    ) {&#10;                        // Barre de difficulté (F, M, D)&#10;                        DifficultyBar(&#10;                            selectedDifficulty = selectedDifficulty,&#10;                            onDifficultySelected = {&#10;                                selectedDifficulty = it&#10;                            },&#10;                            enabled = quizState !is QuizState.Loading&#10;                        )&#10;&#10;                        Spacer(modifier = Modifier.height(24.dp))&#10;&#10;                        // Compteur de questions et score&#10;                        Column(&#10;                            modifier = Modifier.align(Alignment.CenterHorizontally),&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;${currentQuestionIndex + 1}/${questions.size}&quot;,&#10;                                fontSize = 32.sp,&#10;                                fontWeight = FontWeight.Bold&#10;                            )&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            Surface(&#10;                                color = Color.White.copy(alpha = 0.9f),&#10;                                shape = RoundedCornerShape(12.dp),&#10;                                modifier = Modifier.padding(horizontal = 16.dp)&#10;                            ) {&#10;                                Text(&#10;                                    text = &quot;Score: $score pts&quot;,&#10;                                    fontSize = 24.sp,&#10;                                    fontWeight = FontWeight.Bold,&#10;                                    color = MaterialTheme.colorScheme.primary,&#10;                                    modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp)&#10;                                )&#10;                            }&#10;                        }&#10;&#10;                        Spacer(modifier = Modifier.height(24.dp))&#10;&#10;                        // Zone de question&#10;                        QuestionBox(&#10;                            question = currentQuestion.question&#10;                        )&#10;&#10;                        Spacer(modifier = Modifier.height(24.dp))&#10;&#10;                        // Boutons de réponse&#10;                        AnswersGrid(&#10;                            answers = answers,&#10;                            correctAnswer = currentQuestion.correctAnswer,&#10;                            selectedAnswer = selectedAnswer,&#10;                            hasAnswered = hasAnswered,&#10;                            onAnswerSelected = { answer -&gt;&#10;                                if (!hasAnswered) {&#10;                                    selectedAnswer = answer&#10;                                    hasAnswered = true&#10;                                    viewModel.answerQuestion(answer, currentQuestion.correctAnswer, difficultyMultiplier)&#10;                                }&#10;                            }&#10;                        )&#10;                    }&#10;                } else {&#10;                    // Écran de fin de quiz&#10;                    QuizEndScreen(&#10;                        score = score,&#10;                        correctAnswers = correctAnswersCount,&#10;                        totalQuestions = questions.size,&#10;                        onRestart = {&#10;                            viewModel.resetQuiz()&#10;                            val difficulty = when (selectedDifficulty) {&#10;                                Difficulty.FACILE -&gt; &quot;easy&quot;&#10;                                Difficulty.MOYEN -&gt; &quot;medium&quot;&#10;                                Difficulty.DIFFICILE -&gt; &quot;hard&quot;&#10;                            }&#10;                            viewModel.loadQuestions(difficulty)&#10;                        },&#10;                        modifier = Modifier&#10;                            .fillMaxSize()&#10;                            .padding(16.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Bouton de contrôle de musique en bas à droite&#10;        MusicToggleButton(&#10;            isMusicEnabled = isMusicEnabled,&#10;            onToggle = { isMusicEnabled = !isMusicEnabled },&#10;            modifier = Modifier&#10;                .align(Alignment.BottomEnd)&#10;                .padding(16.dp)&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun DifficultyBar(&#10;    selectedDifficulty: Difficulty,&#10;    onDifficultySelected: (Difficulty) -&gt; Unit,&#10;    modifier: Modifier = Modifier,&#10;    enabled: Boolean = true&#10;) {&#10;    Row(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .height(60.dp)&#10;            .border(BorderStroke(2.dp, Color.Black))&#10;            .alpha(0.95f),&#10;        horizontalArrangement = Arrangement.SpaceEvenly&#10;    ) {&#10;        DifficultyButton(&#10;            text = &quot;F&quot;,&#10;            isSelected = selectedDifficulty == Difficulty.FACILE,&#10;            onClick = { onDifficultySelected(Difficulty.FACILE) },&#10;            modifier = Modifier.weight(1f),&#10;            enabled = enabled&#10;        )&#10;&#10;        HorizontalDivider(&#10;            modifier = Modifier&#10;                .width(2.dp)&#10;                .fillMaxHeight(),&#10;            color = Color.Black&#10;        )&#10;&#10;        DifficultyButton(&#10;            text = &quot;M&quot;,&#10;            isSelected = selectedDifficulty == Difficulty.MOYEN,&#10;            onClick = { onDifficultySelected(Difficulty.MOYEN) },&#10;            modifier = Modifier.weight(1f),&#10;            enabled = enabled&#10;        )&#10;&#10;        HorizontalDivider(&#10;            modifier = Modifier&#10;                .width(2.dp)&#10;                .fillMaxHeight(),&#10;            color = Color.Black&#10;        )&#10;&#10;        DifficultyButton(&#10;            text = &quot;D&quot;,&#10;            isSelected = selectedDifficulty == Difficulty.DIFFICILE,&#10;            onClick = { onDifficultySelected(Difficulty.DIFFICILE) },&#10;            modifier = Modifier.weight(1f),&#10;            enabled = enabled&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun DifficultyButton(&#10;    text: String,&#10;    isSelected: Boolean,&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier,&#10;    enabled: Boolean = true&#10;) {&#10;    Button(&#10;        onClick = onClick,&#10;        enabled = enabled,&#10;        modifier = modifier.fillMaxHeight(),&#10;        colors = ButtonDefaults.buttonColors(&#10;            containerColor = if (isSelected) Color.LightGray else Color.White,&#10;            contentColor = Color.Black,&#10;            disabledContainerColor = Color.Gray.copy(alpha = 0.5f),&#10;            disabledContentColor = Color.Black.copy(alpha = 0.5f)&#10;        ),&#10;        shape = RectangleShape&#10;    ) {&#10;        Text(&#10;            text = text,&#10;            fontSize = 24.sp,&#10;            fontWeight = FontWeight.Bold&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun QuestionBox(&#10;    question: String,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Surface(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .height(200.dp)&#10;            .border(BorderStroke(2.dp, Color.Black)),&#10;        color = Color.White.copy(alpha = 0.95f)&#10;    ) {&#10;        Box(&#10;            contentAlignment = Alignment.Center,&#10;            modifier = Modifier.fillMaxSize()&#10;        ) {&#10;            Text(&#10;                text = question,&#10;                fontSize = 20.sp,&#10;                fontWeight = FontWeight.Bold,&#10;                color = Color.Black,&#10;                textAlign = TextAlign.Center,&#10;                modifier = Modifier.padding(16.dp)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun AnswersGrid(&#10;    answers: List&lt;String&gt;,&#10;    correctAnswer: String,&#10;    selectedAnswer: String?,&#10;    hasAnswered: Boolean,&#10;    onAnswerSelected: (String) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Column(&#10;        modifier = modifier.fillMaxWidth(),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;    ) {&#10;        // Première ligne avec 2 boutons&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            AnswerButton(&#10;                answer = answers[0],&#10;                label = &quot;A&quot;,&#10;                isCorrect = answers[0] == correctAnswer,&#10;                isSelected = answers[0] == selectedAnswer,&#10;                hasAnswered = hasAnswered,&#10;                onClick = { onAnswerSelected(answers[0]) },&#10;                modifier = Modifier.weight(1f)&#10;            )&#10;            AnswerButton(&#10;                answer = answers[1],&#10;                label = &quot;B&quot;,&#10;                isCorrect = answers[1] == correctAnswer,&#10;                isSelected = answers[1] == selectedAnswer,&#10;                hasAnswered = hasAnswered,&#10;                onClick = { onAnswerSelected(answers[1]) },&#10;                modifier = Modifier.weight(1f)&#10;            )&#10;        }&#10;&#10;        // Deuxième ligne avec 2 boutons&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            AnswerButton(&#10;                answer = answers[2],&#10;                label = &quot;C&quot;,&#10;                isCorrect = answers[2] == correctAnswer,&#10;                isSelected = answers[2] == selectedAnswer,&#10;                hasAnswered = hasAnswered,&#10;                onClick = { onAnswerSelected(answers[2]) },&#10;                modifier = Modifier.weight(1f)&#10;            )&#10;            AnswerButton(&#10;                answer = answers[3],&#10;                label = &quot;D&quot;,&#10;                isCorrect = answers[3] == correctAnswer,&#10;                isSelected = answers[3] == selectedAnswer,&#10;                hasAnswered = hasAnswered,&#10;                onClick = { onAnswerSelected(answers[3]) },&#10;                modifier = Modifier.weight(1f)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun AnswerButton(&#10;    answer: String,&#10;    label: String,&#10;    isCorrect: Boolean,&#10;    isSelected: Boolean,&#10;    hasAnswered: Boolean,&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val backgroundColor = when {&#10;        !hasAnswered -&gt; Color.White.copy(alpha = 0.95f)&#10;        isCorrect -&gt; Color(0xFF4CAF50) // Vert pour la bonne réponse (toujours)&#10;        isSelected &amp;&amp; !isCorrect -&gt; Color(0xFFF44336) // Rouge pour la mauvaise réponse sélectionnée&#10;        else -&gt; Color.White.copy(alpha = 0.95f)&#10;    }&#10;&#10;    val textColor = when {&#10;        !hasAnswered -&gt; Color.Black&#10;        isCorrect -&gt; Color.White // Texte blanc pour la bonne réponse&#10;        isSelected &amp;&amp; !isCorrect -&gt; Color.White // Texte blanc pour la mauvaise réponse sélectionnée&#10;        else -&gt; Color.Black&#10;    }&#10;&#10;    Button(&#10;        onClick = onClick,&#10;        enabled = !hasAnswered,&#10;        modifier = modifier&#10;            .height(100.dp)&#10;            .border(BorderStroke(2.dp, Color.Black)),&#10;        colors = ButtonDefaults.buttonColors(&#10;            containerColor = backgroundColor,&#10;            contentColor = textColor,&#10;            disabledContainerColor = backgroundColor,&#10;            disabledContentColor = textColor&#10;        ),&#10;        shape = RoundedCornerShape(8.dp),&#10;        contentPadding = PaddingValues(8.dp)&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Center&#10;        ) {&#10;            Text(&#10;                text = label,&#10;                fontSize = 20.sp,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;            Text(&#10;                text = answer,&#10;                fontSize = 14.sp,&#10;                textAlign = TextAlign.Center,&#10;                maxLines = 2&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun QuizEndScreen(&#10;    score: Int,&#10;    correctAnswers: Int,&#10;    totalQuestions: Int,&#10;    onRestart: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Surface(&#10;        modifier = modifier,&#10;        color = Color.White.copy(alpha = 0.9f),&#10;        shape = RoundedCornerShape(16.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(24.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Center&#10;        ) {&#10;            Text(&#10;                text = &quot;Quiz Terminé !&quot;,&#10;                fontSize = 36.sp,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(32.dp))&#10;&#10;            // Score en points&#10;            Text(&#10;                text = &quot;Votre score&quot;,&#10;                fontSize = 24.sp&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            Text(&#10;                text = &quot;$score points&quot;,&#10;                fontSize = 48.sp,&#10;                fontWeight = FontWeight.Bold,&#10;                color = MaterialTheme.colorScheme.primary&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(24.dp))&#10;&#10;            // Nombre de bonnes réponses&#10;            Surface(&#10;                color = Color(0xFF4CAF50).copy(alpha = 0.2f),&#10;                shape = RoundedCornerShape(12.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;✓ $correctAnswers / $totalQuestions bonnes réponses&quot;,&#10;                    fontSize = 20.sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = Color(0xFF2E7D32),&#10;                    modifier = Modifier.padding(horizontal = 16.dp, vertical = 12.dp)&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(48.dp))&#10;&#10;            Button(&#10;                onClick = onRestart,&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .height(60.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Recommencer&quot;,&#10;                    fontSize = 20.sp&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun MusicToggleButton(&#10;    isMusicEnabled: Boolean,&#10;    onToggle: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    FloatingActionButton(&#10;        onClick = onToggle,&#10;        modifier = modifier,&#10;        containerColor = if (isMusicEnabled) MaterialTheme.colorScheme.primaryContainer else MaterialTheme.colorScheme.surfaceVariant,&#10;        contentColor = MaterialTheme.colorScheme.onPrimaryContainer&#10;    ) {&#10;        Text(&#10;            text = if (isMusicEnabled) &quot;&quot; else &quot;&quot;,&#10;            fontSize = 28.sp,&#10;            modifier = Modifier.alpha(if (isMusicEnabled) 1f else 0.6f)&#10;        )&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun QuizScreenPreview() {&#10;    QuizScreen()&#10;}&#10;" />
              <option name="updatedContent" value="package fr.eseo.b3.agtr.narvalo.ui&#10;&#10;import androidx.compose.foundation.BorderStroke&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.ui.draw.alpha&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.RectangleShape&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import fr.eseo.b3.agtr.narvalo.Question.QuizState&#10;import fr.eseo.b3.agtr.narvalo.Question.QuizViewModel&#10;import fr.eseo.b3.agtr.narvalo.R&#10;&#10;enum class Difficulty {&#10;    FACILE, MOYEN, DIFFICILE&#10;}&#10;&#10;@Composable&#10;fun QuizScreen(&#10;    modifier: Modifier = Modifier,&#10;    viewModel: QuizViewModel = viewModel()&#10;) {&#10;    var selectedDifficulty by remember { mutableStateOf(Difficulty.MOYEN) }&#10;    var isMusicEnabled by remember { mutableStateOf(true) }&#10;&#10;    val quizState by viewModel.quizState.collectAsState()&#10;    val currentQuestionIndex by viewModel.currentQuestionIndex.collectAsState()&#10;    val score by viewModel.score.collectAsState()&#10;    val correctAnswersCount by viewModel.correctAnswersCount.collectAsState()&#10;    &#10;    // Calculer le multiplicateur de difficulté&#10;    val difficultyMultiplier = when (selectedDifficulty) {&#10;        Difficulty.FACILE -&gt; 1&#10;        Difficulty.MOYEN -&gt; 3&#10;        Difficulty.DIFFICILE -&gt; 5&#10;    }&#10;&#10;    // Charger les questions au démarrage&#10;    LaunchedEffect(selectedDifficulty) {&#10;        val difficulty = when (selectedDifficulty) {&#10;            Difficulty.FACILE -&gt; &quot;easy&quot;&#10;            Difficulty.MOYEN -&gt; &quot;medium&quot;&#10;            Difficulty.DIFFICILE -&gt; &quot;hard&quot;&#10;        }&#10;        viewModel.loadQuestions(difficulty)&#10;    }&#10;&#10;    Box(&#10;        modifier = modifier.fillMaxSize()&#10;    ) {&#10;        // Image de fond&#10;        Image(&#10;            painter = painterResource(id = R.drawable.background_quiz),&#10;            contentDescription = &quot;Background&quot;,&#10;            modifier = Modifier.fillMaxSize(),&#10;            contentScale = ContentScale.Crop&#10;        )&#10;&#10;        when (val state = quizState) {&#10;            is QuizState.Loading -&gt; {&#10;                CircularProgressIndicator(&#10;                    modifier = Modifier.align(Alignment.Center)&#10;                )&#10;            }&#10;            is QuizState.Error -&gt; {&#10;                Column(&#10;                    modifier = Modifier&#10;                        .align(Alignment.Center)&#10;                        .padding(16.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    Text(&#10;                        text = state.message,&#10;                        color = Color.Red,&#10;                        textAlign = TextAlign.Center&#10;                    )&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                    Button(onClick = { viewModel.loadQuestions() }) {&#10;                        Text(&quot;Réessayer&quot;)&#10;                    }&#10;                }&#10;            }&#10;            is QuizState.Success -&gt; {&#10;                val questions = state.questions&#10;&#10;                if (currentQuestionIndex &lt; questions.size) {&#10;                    val currentQuestion = questions[currentQuestionIndex]&#10;                    val answers = remember(currentQuestionIndex) {&#10;                        currentQuestion.getAllAnswers()&#10;                    }&#10;&#10;                    var selectedAnswer by remember(currentQuestionIndex) { mutableStateOf&lt;String?&gt;(null) }&#10;                    var hasAnswered by remember(currentQuestionIndex) { mutableStateOf(false) }&#10;&#10;                    // Passer automatiquement à la question suivante après un délai&#10;                    LaunchedEffect(hasAnswered) {&#10;                        if (hasAnswered) {&#10;                            kotlinx.coroutines.delay(1000)&#10;                            viewModel.nextQuestion()&#10;                        }&#10;                    }&#10;&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .fillMaxSize()&#10;                            .padding(start = 16.dp, end = 16.dp, top = 16.dp, bottom = 80.dp),&#10;                        verticalArrangement = Arrangement.SpaceBetween&#10;                    ) {&#10;                        // Barre de difficulté (F, M, D)&#10;                        DifficultyBar(&#10;                            selectedDifficulty = selectedDifficulty,&#10;                            onDifficultySelected = {&#10;                                selectedDifficulty = it&#10;                            },&#10;                            enabled = quizState !is QuizState.Loading&#10;                        )&#10;&#10;                        Spacer(modifier = Modifier.height(24.dp))&#10;&#10;                        // Compteur de questions et score&#10;                        Column(&#10;                            modifier = Modifier.align(Alignment.CenterHorizontally),&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;${currentQuestionIndex + 1}/${questions.size}&quot;,&#10;                                fontSize = 32.sp,&#10;                                fontWeight = FontWeight.Bold&#10;                            )&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            Surface(&#10;                                color = Color.White.copy(alpha = 0.9f),&#10;                                shape = RoundedCornerShape(12.dp),&#10;                                modifier = Modifier.padding(horizontal = 16.dp)&#10;                            ) {&#10;                                Text(&#10;                                    text = &quot;Score: $score pts&quot;,&#10;                                    fontSize = 24.sp,&#10;                                    fontWeight = FontWeight.Bold,&#10;                                    color = MaterialTheme.colorScheme.primary,&#10;                                    modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp)&#10;                                )&#10;                            }&#10;                        }&#10;&#10;                        Spacer(modifier = Modifier.height(24.dp))&#10;&#10;                        // Zone de question&#10;                        QuestionBox(&#10;                            question = currentQuestion.question&#10;                        )&#10;&#10;                        Spacer(modifier = Modifier.height(24.dp))&#10;&#10;                        // Boutons de réponse&#10;                        AnswersGrid(&#10;                            answers = answers,&#10;                            correctAnswer = currentQuestion.correctAnswer,&#10;                            selectedAnswer = selectedAnswer,&#10;                            hasAnswered = hasAnswered,&#10;                            onAnswerSelected = { answer -&gt;&#10;                                if (!hasAnswered) {&#10;                                    selectedAnswer = answer&#10;                                    hasAnswered = true&#10;                                    viewModel.answerQuestion(answer, currentQuestion.correctAnswer, difficultyMultiplier)&#10;                                }&#10;                            }&#10;                        )&#10;                    }&#10;                } else {&#10;                    // Écran de fin de quiz&#10;                    QuizEndScreen(&#10;                        score = score,&#10;                        correctAnswers = correctAnswersCount,&#10;                        totalQuestions = questions.size,&#10;                        onRestart = {&#10;                            viewModel.resetQuiz()&#10;                            val difficulty = when (selectedDifficulty) {&#10;                                Difficulty.FACILE -&gt; &quot;easy&quot;&#10;                                Difficulty.MOYEN -&gt; &quot;medium&quot;&#10;                                Difficulty.DIFFICILE -&gt; &quot;hard&quot;&#10;                            }&#10;                            viewModel.loadQuestions(difficulty)&#10;                        },&#10;                        modifier = Modifier&#10;                            .fillMaxSize()&#10;                            .padding(16.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Bouton de contrôle de musique en bas à droite&#10;        MusicToggleButton(&#10;            isMusicEnabled = isMusicEnabled,&#10;            onToggle = { isMusicEnabled = !isMusicEnabled },&#10;            modifier = Modifier&#10;                .align(Alignment.BottomEnd)&#10;                .padding(16.dp)&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun DifficultyBar(&#10;    selectedDifficulty: Difficulty,&#10;    onDifficultySelected: (Difficulty) -&gt; Unit,&#10;    modifier: Modifier = Modifier,&#10;    enabled: Boolean = true&#10;) {&#10;    Row(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .height(60.dp)&#10;            .border(BorderStroke(2.dp, Color.Black))&#10;            .alpha(0.95f),&#10;        horizontalArrangement = Arrangement.SpaceEvenly&#10;    ) {&#10;        DifficultyButton(&#10;            text = &quot;F&quot;,&#10;            isSelected = selectedDifficulty == Difficulty.FACILE,&#10;            onClick = { onDifficultySelected(Difficulty.FACILE) },&#10;            modifier = Modifier.weight(1f),&#10;            enabled = enabled&#10;        )&#10;&#10;        HorizontalDivider(&#10;            modifier = Modifier&#10;                .width(2.dp)&#10;                .fillMaxHeight(),&#10;            color = Color.Black&#10;        )&#10;&#10;        DifficultyButton(&#10;            text = &quot;M&quot;,&#10;            isSelected = selectedDifficulty == Difficulty.MOYEN,&#10;            onClick = { onDifficultySelected(Difficulty.MOYEN) },&#10;            modifier = Modifier.weight(1f),&#10;            enabled = enabled&#10;        )&#10;&#10;        HorizontalDivider(&#10;            modifier = Modifier&#10;                .width(2.dp)&#10;                .fillMaxHeight(),&#10;            color = Color.Black&#10;        )&#10;&#10;        DifficultyButton(&#10;            text = &quot;D&quot;,&#10;            isSelected = selectedDifficulty == Difficulty.DIFFICILE,&#10;            onClick = { onDifficultySelected(Difficulty.DIFFICILE) },&#10;            modifier = Modifier.weight(1f),&#10;            enabled = enabled&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun DifficultyButton(&#10;    text: String,&#10;    isSelected: Boolean,&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier,&#10;    enabled: Boolean = true&#10;) {&#10;    Button(&#10;        onClick = onClick,&#10;        enabled = enabled,&#10;        modifier = modifier.fillMaxHeight(),&#10;        colors = ButtonDefaults.buttonColors(&#10;            containerColor = if (isSelected) Color.LightGray else Color.White,&#10;            contentColor = Color.Black,&#10;            disabledContainerColor = Color.Gray.copy(alpha = 0.5f),&#10;            disabledContentColor = Color.Black.copy(alpha = 0.5f)&#10;        ),&#10;        shape = RectangleShape&#10;    ) {&#10;        Text(&#10;            text = text,&#10;            fontSize = 24.sp,&#10;            fontWeight = FontWeight.Bold&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun QuestionBox(&#10;    question: String,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Surface(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .height(200.dp)&#10;            .border(BorderStroke(2.dp, Color.Black)),&#10;        color = Color.White.copy(alpha = 0.95f)&#10;    ) {&#10;        Box(&#10;            contentAlignment = Alignment.Center,&#10;            modifier = Modifier.fillMaxSize()&#10;        ) {&#10;            Text(&#10;                text = question,&#10;                fontSize = 20.sp,&#10;                fontWeight = FontWeight.Bold,&#10;                color = Color.Black,&#10;                textAlign = TextAlign.Center,&#10;                modifier = Modifier.padding(16.dp)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun AnswersGrid(&#10;    answers: List&lt;String&gt;,&#10;    correctAnswer: String,&#10;    selectedAnswer: String?,&#10;    hasAnswered: Boolean,&#10;    onAnswerSelected: (String) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Column(&#10;        modifier = modifier.fillMaxWidth(),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;    ) {&#10;        // Première ligne avec 2 boutons&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            AnswerButton(&#10;                answer = answers[0],&#10;                label = &quot;A&quot;,&#10;                isCorrect = answers[0] == correctAnswer,&#10;                isSelected = answers[0] == selectedAnswer,&#10;                hasAnswered = hasAnswered,&#10;                onClick = { onAnswerSelected(answers[0]) },&#10;                modifier = Modifier.weight(1f)&#10;            )&#10;            AnswerButton(&#10;                answer = answers[1],&#10;                label = &quot;B&quot;,&#10;                isCorrect = answers[1] == correctAnswer,&#10;                isSelected = answers[1] == selectedAnswer,&#10;                hasAnswered = hasAnswered,&#10;                onClick = { onAnswerSelected(answers[1]) },&#10;                modifier = Modifier.weight(1f)&#10;            )&#10;        }&#10;&#10;        // Deuxième ligne avec 2 boutons&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            AnswerButton(&#10;                answer = answers[2],&#10;                label = &quot;C&quot;,&#10;                isCorrect = answers[2] == correctAnswer,&#10;                isSelected = answers[2] == selectedAnswer,&#10;                hasAnswered = hasAnswered,&#10;                onClick = { onAnswerSelected(answers[2]) },&#10;                modifier = Modifier.weight(1f)&#10;            )&#10;            AnswerButton(&#10;                answer = answers[3],&#10;                label = &quot;D&quot;,&#10;                isCorrect = answers[3] == correctAnswer,&#10;                isSelected = answers[3] == selectedAnswer,&#10;                hasAnswered = hasAnswered,&#10;                onClick = { onAnswerSelected(answers[3]) },&#10;                modifier = Modifier.weight(1f)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun AnswerButton(&#10;    answer: String,&#10;    label: String,&#10;    isCorrect: Boolean,&#10;    isSelected: Boolean,&#10;    hasAnswered: Boolean,&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val backgroundColor = when {&#10;        !hasAnswered -&gt; Color.White.copy(alpha = 0.95f)&#10;        isCorrect -&gt; Color(0xFF4CAF50) // Vert pour la bonne réponse (toujours)&#10;        isSelected &amp;&amp; !isCorrect -&gt; Color(0xFFF44336) // Rouge pour la mauvaise réponse sélectionnée&#10;        else -&gt; Color.White.copy(alpha = 0.95f)&#10;    }&#10;&#10;    val textColor = when {&#10;        !hasAnswered -&gt; Color.Black&#10;        isCorrect -&gt; Color.White // Texte blanc pour la bonne réponse&#10;        isSelected &amp;&amp; !isCorrect -&gt; Color.White // Texte blanc pour la mauvaise réponse sélectionnée&#10;        else -&gt; Color.Black&#10;    }&#10;&#10;    Button(&#10;        onClick = onClick,&#10;        enabled = !hasAnswered,&#10;        modifier = modifier&#10;            .height(100.dp)&#10;            .border(BorderStroke(2.dp, Color.Black)),&#10;        colors = ButtonDefaults.buttonColors(&#10;            containerColor = backgroundColor,&#10;            contentColor = textColor,&#10;            disabledContainerColor = backgroundColor,&#10;            disabledContentColor = textColor&#10;        ),&#10;        shape = RoundedCornerShape(8.dp),&#10;        contentPadding = PaddingValues(8.dp)&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Center&#10;        ) {&#10;            Text(&#10;                text = label,&#10;                fontSize = 20.sp,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;            Text(&#10;                text = answer,&#10;                fontSize = 14.sp,&#10;                textAlign = TextAlign.Center,&#10;                maxLines = 2&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun QuizEndScreen(&#10;    score: Int,&#10;    correctAnswers: Int,&#10;    totalQuestions: Int,&#10;    onRestart: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Surface(&#10;        modifier = modifier,&#10;        color = Color.White.copy(alpha = 0.9f),&#10;        shape = RoundedCornerShape(16.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(24.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Center&#10;        ) {&#10;            Text(&#10;                text = &quot;Quiz Terminé !&quot;,&#10;                fontSize = 36.sp,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(32.dp))&#10;&#10;            // Score en points&#10;            Text(&#10;                text = &quot;Votre score&quot;,&#10;                fontSize = 24.sp&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            Text(&#10;                text = &quot;$score points&quot;,&#10;                fontSize = 48.sp,&#10;                fontWeight = FontWeight.Bold,&#10;                color = MaterialTheme.colorScheme.primary&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(24.dp))&#10;&#10;            // Nombre de bonnes réponses&#10;            Surface(&#10;                color = Color(0xFF4CAF50).copy(alpha = 0.2f),&#10;                shape = RoundedCornerShape(12.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;✓ $correctAnswers / $totalQuestions bonnes réponses&quot;,&#10;                    fontSize = 20.sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = Color(0xFF2E7D32),&#10;                    modifier = Modifier.padding(horizontal = 16.dp, vertical = 12.dp)&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(48.dp))&#10;&#10;            Button(&#10;                onClick = onRestart,&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .height(60.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Recommencer&quot;,&#10;                    fontSize = 20.sp&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun MusicToggleButton(&#10;    isMusicEnabled: Boolean,&#10;    onToggle: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    FloatingActionButton(&#10;        onClick = onToggle,&#10;        modifier = modifier,&#10;        containerColor = if (isMusicEnabled) MaterialTheme.colorScheme.primaryContainer else MaterialTheme.colorScheme.surfaceVariant,&#10;        contentColor = MaterialTheme.colorScheme.onPrimaryContainer&#10;    ) {&#10;        Text(&#10;            text = if (isMusicEnabled) &quot;&quot; else &quot;&quot;,&#10;            fontSize = 28.sp,&#10;            modifier = Modifier.alpha(if (isMusicEnabled) 1f else 0.6f)&#10;        )&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun QuizScreenPreview() {&#10;    QuizScreen()&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>